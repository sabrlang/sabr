$true -1 #macro ( -- b )
$false 0 #macro ( -- b)
$null 0 #macro ( -- addr )
$not { 0 = } #macro ( x -- b )
$buf { 0 != } #macro ( x -- b )
$and { buf swap buf & } #macro ( x1 x2 -- b )
$or { buf swap buf | } #macro ( x1 x2 -- b )
$select { if drop else nip end } #macro ( x1 x2 b -- x )

$nullset { 0 swap set } #macro ( id -- )

$~set { dup exec ~ swap set } #macro ( id -- )
$++set { dup exec ++ swap set } #macro ( id -- )
$--set { dup exec -- swap set } #macro ( id -- )
$notset { dup exec not swap set } #macro ( id -- )
$bufset { dup exec not swap set } #macro ( id -- )

$+set { dup exec rot + swap set } #macro ( n id -- )
$-set { dup exec rot - swap set } #macro ( n id -- )
$*set { dup exec rot * swap set } #macro ( n id -- )
$/set { dup exec rot / swap set } #macro ( n id -- )
$%set { dup exec rot % swap set } #macro ( n id -- )
$f+set { dup exec rot f+ swap set } #macro ( f id -- )
$f-set { dup exec rot f- swap set } #macro ( f id -- )
$f*set { dup exec rot f* swap set } #macro ( f id -- )
$f/set { dup exec rot f/ swap set } #macro ( f id -- )
$f%set { dup exec rot f% swap set } #macro ( f id -- )
$<<set { dup exec rot << swap set } #macro ( x id -- )
$>>set { dup exec rot >> swap set } #macro ( x id -- )
$&set { dup exec rot & swap set } #macro ( x id -- )
$|set { dup exec rot | swap set } #macro ( x id -- )
$^set { dup exec rot ^ swap set } #macro ( x id -- )
$andset { dup exec rot and swap set } #macro ( x id -- )
$orset { dup exec rot or swap set } #macro ( x id -- )

$nullstore { 0 swap store } #macro ( addr -- )

$++store { dup fetch ++ swap store } #macro ( addr -- )
$--store { dup fetch -- swap store } #macro ( addr -- )
$~store { dup fetch ~ swap store } #macro ( addr -- )
$notstore { dup fetch not swap store } #macro ( addr -- )
$bufstore { dup fetch buf swap store } #macro ( addr -- )

$+store { dup fetch rot + swap store } #macro ( n addr -- )
$-store { dup fetch rot - swap store } #macro ( n addr -- )
$*store { dup fetch rot * swap store } #macro ( n addr -- )
$/store { dup fetch rot / swap store } #macro ( n addr -- )
$%store { dup fetch rot % swap store } #macro ( n addr -- )
$f+store { dup fetch rot f+ swap store } #macro ( f addr -- )
$f-store { dup fetch rot f- swap store } #macro ( f addr -- )
$f*store { dup fetch rot f* swap store } #macro ( f addr -- )
$f/store { dup fetch rot f/ swap store } #macro ( f addr -- )
$f%store { dup fetch rot f% swap store } #macro ( f addr -- )
$<<store { dup fetch rot << swap store } #macro ( x addr -- )
$>>store { dup fetch rot >> swap store } #macro ( x addr -- )
$&store { dup fetch rot & swap store } #macro ( x addr -- )
$|store { dup fetch rot | swap store } #macro ( x addr -- )
$^store { dup fetch rot ^ swap store } #macro ( x addr -- )
$andstore { dup fetch rot and swap store } #macro ( x addr -- )
$orstore { dup fetch rot or swap store } #macro ( x addr -- )

$cr { '\n' putc } #macro ( -- )
$space { ' ' putc } #macro ( -- )
$putsln { puts cr } #macro ( addr -- )

$cells { 8 * } #macro ( u -- u )
$at { swap 8 * + } #macro ( u addr -- addr )
$alloc~? { alloc dup not if } #macro ( u -- addr )

$method {
	func $this set
} #macro ( id -- | func ... )
